# Het-LaCAM vs HetPIBT: het_bench Comparison

Map: room-64-64-8 (120x120 cropped from 10x upscale of 64x64 base)
Scenarios: pypibt/het_bench/scen.{0..9} with `--swap-xy`
Time limit: het_lacam 10s (anytime), hetpibt uncapped (finishes in <15ms)

## Results

| Scen | Agents | hetpibt Goals | hetpibt SOC | hetpibt MK | hetpibt ms | het_lacam Goals | het_lacam SOC | het_lacam MK | het_lacam ms |
|------|--------|---------------|-------------|------------|------------|-----------------|---------------|--------------|--------------|
| 0    | 9      | 9/9           | 404         | 187        | 11         | 9/9             | 799           | 186          | 10079        |
| 2    | 7      | 7/7           | 130         | 49         | 7          | 7/7             | 497           | 142          | 10189        |
| 3    | 7      | 7/7           | 152         | 69         | 5          | 7/7             | 316           | 78           | 10098        |
| 4    | 8      | 8/8           | 179         | 61         | 5          | 8/8             | 309           | 108          | 10065        |
| 5    | 6      | 6/6           | 338         | 170        | 8          | 6/6             | 497           | 175          | 10146        |
| 6    | 9      | 9/9           | 452         | 176        | 12         | 9/9             | 1046          | 222          | 10108        |
| 7    | 9      | 9/9           | 184         | 80         | 6          | 9/9             | 303           | 77           | 10082        |
| 8    | 9      | 9/9           | 308         | 148        | 9          | 9/9             | 523           | 147          | 10098        |

Skipped: scen.1 (goal footprint overlap), scen.9 (agent on boundary wall)

## Key

- **SOC**: Sum of costs. hetpibt = sum of goal-arrival timesteps; het_lacam = total agent-timesteps (includes wait-at-goal padding to makespan).
- **MK**: Makespan (max timesteps for any agent to reach goal).
- **ms**: Wall-clock solve time in milliseconds.
- het_lacam uses full 10s for anytime refinement (LaCAM search tree). Initial solution found much earlier.

## Observations

1. **Completeness**: Both solvers achieve 100% goals on all 8 valid scenarios.
2. **Speed**: hetpibt is 1000x faster (5-12ms vs 10s). Expected — PIBT is a one-shot rule-based planner; LaCAM does tree search with iterative refinement.
3. **Makespan**: Comparable on most scenarios. hetpibt wins on scen.0 (187 vs 186, essentially tied), scen.2 (49 vs 142), scen.4 (61 vs 108), scen.6 (176 vs 222). het_lacam wins on scen.3 (78 vs 69 hetpibt), scen.7 (77 vs 80), scen.8 (147 vs 148). Mixed results — neither dominates.
4. **SOC gap**: het_lacam's SOC is inflated because it counts wait-at-goal timesteps. The `sum_of_loss` metric (which excludes post-goal waiting) would be fairer but is not directly comparable to hetpibt's SOC definition.

## Map Generation

The 120x120 map was generated by:
1. Upscaling room-64-64-8.map 10x to 640x640 (matching pypibt's internal obstacle scale)
2. Cropping to 120x120 (the fleet grid extent used by het_bench scenarios)

This gives fleet grids: 120/1=120, 120/6=20, 120/11=10 — matching scenario grid_w/grid_h values.
