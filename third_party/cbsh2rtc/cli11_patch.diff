diff --git a/CMakeLists.txt b/CMakeLists.txt
index 78dcd1c..274d69b 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,19 +1,23 @@
+cmake_minimum_required(VERSION 3.10)
 project(cbs)
 
-cmake_minimum_required (VERSION 2.6)
-
 IF(NOT CMAKE_BUILD_TYPE)
-    SET(CMAKE_BUILD_TYPE "RELEASE")
+    SET(CMAKE_BUILD_TYPE "Release")
 ENDIF()
 
-set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++14")
+set(CMAKE_CXX_STANDARD 14)
+set(CMAKE_CXX_STANDARD_REQUIRED ON)
 
 include_directories("inc")
 file(GLOB SOURCES "src/*.cpp")
 add_executable(cbs ${SOURCES})
 
-# Find Boost
-find_package(Boost REQUIRED COMPONENTS program_options system filesystem)
-include_directories( ${Boost_INCLUDE_DIRS} )
-target_link_libraries(cbs ${Boost_LIBRARIES})
+# Boost â€” header-only (heap, unordered, tokenizer)
+# program_options replaced by CLI11 (in inc/)
+if(BOOST_ROOT)
+    include_directories(${BOOST_ROOT})
+else()
+    find_package(Boost REQUIRED)
+    include_directories(${Boost_INCLUDE_DIRS})
+endif()
 
diff --git a/src/driver.cpp b/src/driver.cpp
index e3b14ee..27a744d 100644
--- a/src/driver.cpp
+++ b/src/driver.cpp
@@ -6,74 +6,77 @@
 
 /*driver.cpp
 * Solve a MAPF instance on 2D grids.
+* Modified: replaced boost::program_options with CLI11 for portability.
 */
-#include <boost/program_options.hpp>
-#include <boost/tokenizer.hpp>
+#include "CLI11.hpp"
 #include "CBS.h"
 
 
 /* Main function */
 int main(int argc, char** argv)
 {
-	namespace po = boost::program_options;
-	// Declare the supported options.
-	po::options_description desc("Allowed options");
-	desc.add_options()
-		("help", "produce help message")
-
-		// params for the input instance and experiment settings
-		("map,m", po::value<string>()->required(), "input file for map")
-		("agents,a", po::value<string>()->required(), "input file for agents")
-		("output,o", po::value<string>(), "output file for schedule")
-		("outputPaths", po::value<string>(), "output file for paths")
-		("agentNum,k", po::value<int>()->default_value(0), "number of agents")
-		("cutoffTime,t", po::value<double>()->default_value(60), "cutoff time (seconds)")
-		("nodeLimit", po::value<int>()->default_value(MAX_NODES), "node limit")
-		("screen,s", po::value<int>()->default_value(1), "screen option (0: none; 1: results; 2:all)")
-		("seed,d", po::value<int>()->default_value(0), "random seed")
-		("stats", po::value<bool>()->default_value(false), "write to files some statistics")
-		("agentIdx", po::value<string>()->default_value(""), "customize the indices of the agents (e.g., \"0,1\")")
-
-		// params for instance generators
-		("rows", po::value<int>()->default_value(0), "number of rows")
-		("cols", po::value<int>()->default_value(0), "number of columns")
-		("obs", po::value<int>()->default_value(0), "number of obstacles")
-		("warehouseWidth", po::value<int>()->default_value(0), "width of working stations on both sides, for generating instances")
-
-		// params for CBS
-		("heuristics", po::value<string>()->default_value("WDG"), "heuristics for the high-level search (Zero, CG,DG, WDG)")
-		("prioritizingConflicts", po::value<bool>()->default_value(true), "conflict priortization. If true, conflictSelection is used as a tie-breaking rule.")
-		("bypass", po::value<bool>()->default_value(true), "Bypass1")
-		("disjointSplitting", po::value<bool>()->default_value(false), "disjoint splitting")
-		("rectangleReasoning", po::value<string>()->default_value("GR"), "rectangle reasoning strategy (None, R, RM, GR, Disjoint)")
-		("corridorReasoning", po::value<string>()->default_value("GC"), " corridor reasoning strategy (None, C, PC, STC, GC, Disjoint")
-		("mutexReasoning", po::value<bool>()->default_value(false), "Using mutex reasoning")
-		("targetReasoning", po::value<bool>()->default_value(true), "Using target reasoning")
-		("restart", po::value<int>()->default_value(1), "number of restart times (at least 1)")
-		("sipp", po::value<bool>()->default_value(false), "using sipp as the single agent solver")
-		;
-
-	po::variables_map vm;
-	po::store(po::parse_command_line(argc, argv, desc), vm);
-
-	if (vm.count("help"))
-	{
-		cout << desc << endl;
-		return 1;
-	}
+	// CLI11 argument parsing (replaces boost::program_options)
+	CLI::App app{"CBSH2-RTC: CBS with heuristics, rectangle, target & corridor reasoning"};
+
+	string map_file, agents_file, output_file, outputPaths_file;
+	int agentNum = 0;
+	double cutoffTime = 60;
+	int nodeLimit = MAX_NODES;
+	int screen = 1;
+	int seed = 0;
+	bool stats = false;
+	string agentIdx = "";
+	int rows = 0, cols = 0, obs = 0, warehouseWidth = 0;
+	string heuristics_str = "WDG";
+	bool prioritizingConflicts = true;
+	bool bypass = true;
+	bool disjointSplitting = false;
+	string rectangleReasoning_str = "GR";
+	string corridorReasoning_str = "GC";
+	bool mutexReasoning = false;
+	bool targetReasoning = true;
+	int restart = 1;
+	bool sipp = false;
+
+	app.add_option("-m,--map", map_file, "input file for map")->required();
+	app.add_option("-a,--agents", agents_file, "input file for agents")->required();
+	app.add_option("-o,--output", output_file, "output file for schedule");
+	app.add_option("--outputPaths", outputPaths_file, "output file for paths");
+	app.add_option("-k,--agentNum", agentNum, "number of agents")->default_val(0);
+	app.add_option("-t,--cutoffTime", cutoffTime, "cutoff time (seconds)")->default_val(60);
+	app.add_option("--nodeLimit", nodeLimit, "node limit")->default_val(MAX_NODES);
+	app.add_option("-s,--screen", screen, "screen option (0: none; 1: results; 2:all)")->default_val(1);
+	app.add_option("-d,--seed", seed, "random seed")->default_val(0);
+	app.add_flag("--stats", stats, "write to files some statistics");
+	app.add_option("--agentIdx", agentIdx, "customize the indices of the agents (e.g., \"0,1\")")->default_val("");
+	app.add_option("--rows", rows, "number of rows")->default_val(0);
+	app.add_option("--cols", cols, "number of columns")->default_val(0);
+	app.add_option("--obs", obs, "number of obstacles")->default_val(0);
+	app.add_option("--warehouseWidth", warehouseWidth, "width of working stations on both sides")->default_val(0);
+	app.add_option("--heuristics", heuristics_str, "heuristics for the high-level search (Zero, CG, DG, WDG)")->default_val("WDG");
+	app.add_flag("--prioritizingConflicts,!--no-prioritizingConflicts", prioritizingConflicts, "conflict prioritization")->default_val(true);
+	app.add_flag("--bypass,!--no-bypass", bypass, "Bypass1")->default_val(true);
+	app.add_flag("--disjointSplitting,!--no-disjointSplitting", disjointSplitting, "disjoint splitting")->default_val(false);
+	app.add_option("--rectangleReasoning", rectangleReasoning_str, "rectangle reasoning strategy (None, R, RM, GR, Disjoint)")->default_val("GR");
+	app.add_option("--corridorReasoning", corridorReasoning_str, "corridor reasoning strategy (None, C, PC, STC, GC, Disjoint)")->default_val("GC");
+	app.add_flag("--mutexReasoning,!--no-mutexReasoning", mutexReasoning, "Using mutex reasoning")->default_val(false);
+	app.add_flag("--targetReasoning,!--no-targetReasoning", targetReasoning, "Using target reasoning")->default_val(true);
+	app.add_option("--restart", restart, "number of restart times (at least 1)")->default_val(1);
+	app.add_flag("--sipp,!--no-sipp", sipp, "using sipp as the single agent solver")->default_val(false);
+
+	CLI11_PARSE(app, argc, argv);
 
-	po::notify(vm);
 	/////////////////////////////////////////////////////////////////////////
 	/// check the correctness and consistence of params
     //////////////////////////////////////////////////////////////////////
 	heuristics_type h;
-	if (vm["heuristics"].as<string>() == "Zero")
+	if (heuristics_str == "Zero")
 		h = heuristics_type::ZERO;
-	else if (vm["heuristics"].as<string>() == "CG")
+	else if (heuristics_str == "CG")
 		h = heuristics_type::CG;
-	else if (vm["heuristics"].as<string>() == "DG")
+	else if (heuristics_str == "DG")
 		h = heuristics_type::DG;
-	else if (vm["heuristics"].as<string>() == "WDG")
+	else if (heuristics_str == "WDG")
 		h = heuristics_type::WDG;
 	else
 	{
@@ -82,16 +85,16 @@ int main(int argc, char** argv)
 	}
 
 	rectangle_strategy r;
-	if (vm["rectangleReasoning"].as<string>() == "None")
-		r = rectangle_strategy::NR;  // no rectangle reasoning
-	else if (vm["rectangleReasoning"].as<string>() == "R")
-		r = rectangle_strategy::R;  // rectangle reasoning for entire paths
-	else if (vm["rectangleReasoning"].as<string>() == "RM")
-		r = rectangle_strategy::RM;  // rectangle reasoning for path segments
-    else if (vm["rectangleReasoning"].as<string>() == "GR")
-        r = rectangle_strategy::GR;  // generalized rectangle reasoning
-	else if (vm["rectangleReasoning"].as<string>() == "Disjoint")
-		r = rectangle_strategy::DR; // disjoint rectangle reasoning
+	if (rectangleReasoning_str == "None")
+		r = rectangle_strategy::NR;
+	else if (rectangleReasoning_str == "R")
+		r = rectangle_strategy::R;
+	else if (rectangleReasoning_str == "RM")
+		r = rectangle_strategy::RM;
+    else if (rectangleReasoning_str == "GR")
+        r = rectangle_strategy::GR;
+	else if (rectangleReasoning_str == "Disjoint")
+		r = rectangle_strategy::DR;
 	else
 	{
 		cout << "WRONG rectangle reasoning strategy!" << endl;
@@ -99,18 +102,18 @@ int main(int argc, char** argv)
 	}
 
 	corridor_strategy c;
-	if (vm["corridorReasoning"].as<string>() == "None")
-		c = corridor_strategy::NC;  // no corridor reasoning
-	else if (vm["corridorReasoning"].as<string>() == "C")
-		c = corridor_strategy::C;  // corridor reasoning
-    else if (vm["corridorReasoning"].as<string>() == "PC")
-        c = corridor_strategy::PC;  // corridor + pseudo-corridor reasoning
-    else if (vm["corridorReasoning"].as<string>() == "STC")
-        c = corridor_strategy::STC;  // corridor with start-target reasoning
-    else if (vm["corridorReasoning"].as<string>() == "GC")
-        c = corridor_strategy::GC;  // generalized corridor reasoning = corridor with start-target + pseudo-corridor
-	else if (vm["corridorReasoning"].as<string>() == "Disjoint")
-		c = corridor_strategy::DC; // disjoint corridor reasoning
+	if (corridorReasoning_str == "None")
+		c = corridor_strategy::NC;
+	else if (corridorReasoning_str == "C")
+		c = corridor_strategy::C;
+    else if (corridorReasoning_str == "PC")
+        c = corridor_strategy::PC;
+    else if (corridorReasoning_str == "STC")
+        c = corridor_strategy::STC;
+    else if (corridorReasoning_str == "GC")
+        c = corridor_strategy::GC;
+	else if (corridorReasoning_str == "Disjoint")
+		c = corridor_strategy::DC;
 	else
 	{
 		cout << "WRONG corridor reasoning strategy!" << endl;
@@ -121,29 +124,29 @@ int main(int argc, char** argv)
 	///////////////////////////////////////////////////////////////////////////
 	/// load the instance
     //////////////////////////////////////////////////////////////////////
-	Instance instance(vm["map"].as<string>(), vm["agents"].as<string>(),
-		vm["agentNum"].as<int>(), vm["agentIdx"].as<string>(),
-		vm["rows"].as<int>(), vm["cols"].as<int>(), vm["obs"].as<int>(), vm["warehouseWidth"].as<int>());
+	Instance instance(map_file, agents_file,
+		agentNum, agentIdx,
+		rows, cols, obs, warehouseWidth);
 
-	srand(vm["seed"].as<int>());
+	srand(seed);
 
-	int runs = vm["restart"].as<int>();
+	int runs = restart;
 
 
 	//////////////////////////////////////////////////////////////////////
 	/// initialize the solver
     //////////////////////////////////////////////////////////////////////
-	CBS cbs(instance, vm["sipp"].as<bool>(), vm["screen"].as<int>());
-	cbs.setPrioritizeConflicts(vm["prioritizingConflicts"].as<bool>());
-	cbs.setDisjointSplitting(vm["disjointSplitting"].as<bool>());
-	cbs.setBypass(vm["bypass"].as<bool>());
+	CBS cbs(instance, sipp, screen);
+	cbs.setPrioritizeConflicts(prioritizingConflicts);
+	cbs.setDisjointSplitting(disjointSplitting);
+	cbs.setBypass(bypass);
 	cbs.setRectangleReasoning(r);
 	cbs.setCorridorReasoning(c);
 	cbs.setHeuristicType(h);
-	cbs.setTargetReasoning(vm["targetReasoning"].as<bool>());
-	cbs.setMutexReasoning(vm["mutexReasoning"].as<bool>());
-	cbs.setSavingStats(vm["stats"].as<bool>());
-	cbs.setNodeLimit(vm["nodeLimit"].as<int>());
+	cbs.setTargetReasoning(targetReasoning);
+	cbs.setMutexReasoning(mutexReasoning);
+	cbs.setSavingStats(stats);
+	cbs.setNodeLimit(nodeLimit);
 
 
 	//////////////////////////////////////////////////////////////////////
@@ -154,7 +157,7 @@ int main(int argc, char** argv)
 	for (int i = 0; i < runs; i++)
 	{
 		cbs.clear();
-		cbs.solve(vm["cutoffTime"].as<double>(), min_f_val);
+		cbs.solve(cutoffTime, min_f_val);
 		runtime += cbs.runtime;
 		if (cbs.solution_found)
 			break;
@@ -166,15 +169,14 @@ int main(int argc, char** argv)
     //////////////////////////////////////////////////////////////////////
     /// write results to files
     //////////////////////////////////////////////////////////////////////
-	if (vm.count("output"))
-		cbs.saveResults(vm["output"].as<string>(), vm["agents"].as<string>()+":"+ vm["agentIdx"].as<string>());
-	// cbs.saveCT(vm["output"].as<string>() + ".tree"); // for debug
-	if (vm["stats"].as<bool>())
+	if (!output_file.empty())
+		cbs.saveResults(output_file, agents_file + ":" + agentIdx);
+	if (stats)
 	{
-		cbs.saveStats(vm["output"].as<string>(), vm["agents"].as<string>() + ":" + vm["agentIdx"].as<string>());
+		cbs.saveStats(output_file, agents_file + ":" + agentIdx);
 	}
-    if (cbs.solution_found && vm.count("outputPaths"))
-        cbs.savePaths(vm["outputPaths"].as<string>());
+    if (cbs.solution_found && !outputPaths_file.empty())
+        cbs.savePaths(outputPaths_file);
 	cbs.clearSearchEngines();
 	return 0;
 
